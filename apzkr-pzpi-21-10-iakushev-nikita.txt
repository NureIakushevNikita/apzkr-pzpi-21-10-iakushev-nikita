Міністерство освіти і науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук


Кафедра програмної інженерії


КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для організації роботи торгівельного центру


		Студент гр. ПЗПІ-21-10	_________________ Якушев Н. О.
							(підпис)
		Керівник роботи			_________________ доц. Лещинська І.О.
							(підпис)
							      Роботу захищено «__» ______ 2024.р
							      з оцінкою _______________________
		Комісія:				_______________ доц. Лещинський В.О.
								(підпис)
							_______________ доц. Лещинська І.О.
								(підпис)
							_______________ ст. викл. Сокорчук І.П.
								(підпис)

Харків
2024 р.
Харківський національний університет радіоелектроніки

Факультет  комп’ютерних наук               Кафедра програмної інженерії                  _
Спеціальність 121 – Інженерія програмного забезпечення                                         _
Курс          3           Семестр                                          6                                                  _
Навчальна дисципліна Архітектура програмного забезпечення                                _

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

.                                                 Якушева Нікіти Олеговича                                             .
1. Тема проєкту: Програмна система для організації роботи торгівельного центру.
2. Термін узгодження завдання курсової роботи « 28 »     березня    . 2024 р.
3. Термін здачі студентом закінченої роботи « 8 »    червня   . 2024 р.
4. Вихідні дані до проєкту: завдання щодо розробки унікальної програмної системи з подальшою можливістю монетизації, яка має бути масштабованою, орієнтованою на масового користувача, підтримувати інтернаціоналізацію та локалізацію, із забезпеченням захисту персональних даних та відповідати сучасним стандартам щодо захисту даних. Програмна система повинна включати такі компоненти: серверна частина, клієнтська частина, мобільний програмний застосунок.                                                                                                    .
5. Зміст пояснювальної записки (перелік питань, що належить розробити) вступ, загальні вимоги щодо програмної системи, розробка серверної частини програмної системи, розробка клієнтської частини програмної системи, розробка мобільної частини програмної системи, висновки, перелік джерел посилань, додатки.
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) UML діаграма розгортання, Use-case діаграма, ER-модель даних, UML діаграма станів, UML діаграма пакетів, UML діаграма компонентів.

КАЛЕНДАРНИЙ ПЛАН

№	Назва етапів курсової роботи	Термін виконання
етапів роботи	Примітка
1	Функціональна специфікація
програмного проєкту	20.03.2024	Виконано
2	Проектування програмного
проєкту	28.03.2024	Виконано
3	Кодування програмного проєкту	23.05.2024	Виконано
4	Оформлення пояснювальної записки	08.06.2024	Виконано
5	Захист курсової роботи	08.06.2024	Виконано

Дата видачі завдання «	  20   »	березня	 2024 р.

		Керівник 				 	          	      доц. Лещинська І.О.
								(підпис)

Завдання прийняв до виконання
ст. гр. ПЗПІ-21-10					      Якушев Н.О.
					     (підпис)



РЕФЕРАТ


	Пояснювальна записка: 59 сторінок, 4 додатки, 11 рисунків, 2 таблиці, 6 переліків посилання.
	АДМІНІСТРАТОР ТОРГІВЕЛЬНОГО ЦЕНТРУ, ВІДВІДУВАННЯ МАГАЗИНУ, ЗАМОВЛЕННЯ, МАГАЗИН, МЕРЕЖА ТОРГІВЕЛЬНИХ ЦЕНТРІВ, РОБІТНИК МАГАЗИНУ, РОБОЧІ ЗМІНИ, ТОРГІВЕЛЬНИЙ ЦЕНТР.
	 Об’єктом розробки є проблема щодо організації роботи сучасних торгівельних центрів. Організація роботи торгівельних центрів включає в себе продаж та купівля товарів, управляння покупками та замовленнями, організація робочих змін для робітників, аналіз кількості відвідувань магазинів торгівельних центрів. Усі ці перелічені процеси мають бути автоматизовані, для полегшення роботи торгівельних центрів.
	Метою роботи є створення програмної системи для організації роботи торгівельного центру, яка дозволяє створювати замовлення, управляти ними, автоматично розробляти робочий графік для робітників, створювати персонал для магазину, управляти даними щодо відвідування магазинів покупцями, отримувати результати аналізу даних щодо відвідування.
	В якості методів розробки було обрано: мову програмування Java Script та фреймворк Node JS для розробки серверної частини, хмарну реляційну модель бази даних SQL Server для зберігання даних користувачів, мову програмування Java Script та бібліотеку React для розробки клієнтської частини, мову програмування Kotlin для розробки мобільної частини програмної системи для платформи Android. А також для розгортання програмної системи було обрано хмарний сервіс Microsoft Azure та контейнерний метод розгортання.
	В результаті виконання курсової роботи було спроєктовано та розроблено програмну систему для організації роботи торгівельного центру, яка включає в себе серверну частину, клієнтську частину та мобільну частину.


ЗМІСТ


Вступ…………………………………………………………………………………….6
1	Загальні відомості щодо програмної системи……………………..........................7
1.1.	Специфікація програмного забезпечення……………………………………...7
1.2.	Архітектура програмного забезпечення……………………………………….7
2	Розробка серверної частини програмної системи…………………………………9
2.1.	Проєктування серверної частини………………………………………………9
2.2.	Опис бази даних та сховища даних…………………………………………...11
2.3.	Архітектура серверної частини……………………………………………….13
2.4.	Опис специфікації Rest API…………………………………………………...13
2.5.	Кодування серверної частини…………………………………………………13
2.6.	Опис дотриманих вимог щодо захисту даних та безпеки даних в системі….14
2.7.	Реалізація локалізації та інтернаціоналізації в системі……………………...15
3	Розробка клієнтської частини програмної системи……………………………...16
3.1.	Архітектура клієнтської частини………………………………………..........16
3.2.	Кодування клієнтської частини……………………………………….………18
4	Розробка мобільної частини програмної системи……………………………….19
4.1.	Проєктування мобільної частини……………………………………………..19
4.2.	Архітектура мобільної частини……………………….………………………21
4.3.	Реалізація локалізації в мобільній частині…………………………………...23
Висновки……………………………………………………………………………….24
Перелік джерел посилання…………………………………………………………...25
Додаток А Специфікація програмного забезпечення……………..………………..26
Додаток Б Таблиця для опису специфікації Rest API………………………………40
Додаток В Програмний код серверної частини……………………………………..47
Додаток Г Програмний код Клієнтської частини…………………………………...52


ВСТУП


	Ми маємо декілька проблем щодо роботи сучасних торгівельних центрів. Серед проблем можна виділити продаж та купівля товарів, управління замовленнями покупців, організацію робочих змін для працівників та визначення рівня зацікавленості покупців магазинами. Отже, пошук вирішення даних проблем і став поштовхом до створення програмної системи для організації роботи торгівельного центру.
	Наша програмна система є актуальною, тому що на сьогоднішній день відсутнє комплексне рішення усіх перелічених проблем користувачів.
	Наша програмна система орієнтована на сферу електронної комерції, бізнесу, а також на управління робочими місцями та графіками роботи працівників магазинів.
	Отже, метою курсової роботи є створення програмної система для організації роботи торгівельного центру, яка складається з серверної, клієнтської та мобільної частин, та вирішує проблеми купівлі та продажу товарів у торгівельних центрах, управління замовленнями покупців, організації робочих змін у магазинах, визначення зацікавленості покупців магазинами.


1 ЗАГАЛЬНІ ВІДОМОСТІ ЩОДО ПРОГРАМНОЇ СИСТЕМИ
	1.1 Специфікація програмного забезпечення


	Для розробки програмного забезпечення необхідний спеціальний документ – специфікація ПЗ, в якому буде наведено опис предметної галузі розробки, загальні  та програмні вимоги до системи. Розроблену специфікацію програмного забезпечення наведено в додатку А.


	1.2 Архітектура програмної системи


	Архітектура нашої програмної системи має назву багаторівнева клієнт-серверна архітектура [1-2].
	Ми маємо такі рівні в нашій архітектурі:
а)	клієнтський рівень;
1)	веб-клієнт – браузерний застосунок, який взаємодіє з користувачем та відправляє запити до серверу;
2)	мобільний клієнт – Android-застосунок, який також взаємодіє з користувачем та відправляє запити до серверу застосунків;
б)	серверний рівень;
1)	сервер – обробляє бізнес-логіку, виконує обчислення, перевіряє права доступу, оброблює дані користувачів;
2)	веб-сервер – обслуговує веб-клієнт, передаючи файли веб-сторінок та перенаправляючи запити до серверу;
в)	рівень даних;
1)	база даних – зберігає дані, забезпечує їх цілісність та надає до них доступ;
2)	сховище blob-об’єктів – зберігає контейнери, в яких знаходяться зображення, які відображаються на веб-клієнті.
	Відобразимо нашу архітектуру на діаграмі розгортання (див. рис. 1.1).


Рисунок 1.1 – Діаграма розгортання програмної системи

	Таким чином, ми побудували діаграму розгортання, яка показує нам загальну архітектуру нашої програмної системи, та як компоненти системи взаємодіють між собою.


2 РОЗРОБКА СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ
	2.1 Проєктування серверної частини


	Першим чином виділимо акторів програмної системи, які будуть виконувати функції в системі:
-	Користувач: відвідувач торгівельного центру, який здійснює покупки в магазинах.
-	Адміністратор торгівельного центру: користувач, який управляє працівниками торгівельного центру та асортиментом магазинів.
-	Робітник магазину: управляє замовленнями користувачів.
	Відобразимо даних акторів та відповідні їм доступні функції на Use-case діаграмі. На рисунку 2.1 наведено Use-case діаграму для звичайного користувача.


Рисунок 2.1 – Use-case діаграма для користувача
	На рисунку 2.2 наведено Use-case діаграму для адміністратора торгівельного центру та робітника магазину.


Рисунок 2.2 – Use-case діаграма для адміністратора торгівельного центру та робітника магазину

	Далі спроєктуєму UML діаграму станів нашої програмної системи.
	Для створення діаграми станів виділимо такі основні стани в системі:
-	Авторизація та реєстрація.
-	Оформлення замовлення.
-	Робота з даними про відвідування магазинів користувачем.
-	Особистий кабінет.
-	Керування замовленнями користувачів.
-	Налаштування робочих змін для робітників.
-	Експорт даних.
	Розроблену діаграму станів наведено на рисунку 2.3


Рисунок 2.3 – UML діаграма станів програмної системи

	Отже, ми створили діаграму станів, яка показує поведінку системи в залежності від поточного стану.


	2.2 Опис бази даних та сховища даних


	Виділимо такі сутності в нашій програмній системі:
-	Користувач: містить інформацію про всіх користувачів системи.
-	Робітник: робітник магазину торгівельного центру.
-	Адміністратор: адміністратор торгівельного центру.
-	Замовлення: замовлення, які здійснюють користувачі.
-	Деталі замовлення: товари, які містяться в замовленні.
-	Знижка: знижка, яка застосовується користувачем до замовлення, для пониження вартості товарів.
-	Мережа торгівельних центрів: окремі торгівельні центри організовують мережу.
-	Торгівельний центр: сукупність магазинів.
-	Магазин: містить товари, які користувачі можуть придбати.
-	Товар: товар магазину, який може придбати користувач.
-	Відвідування: містить інформацію про вхід користувача в магазин та його вихід з магазину.
-	Зміна: зміна робітника в магазині.
	Усі дані нашої програмної системи є структурованими, тому було обрано саме реляційну модель для зберігання даних. Але також в системі присутні неструктуровані елементи, наприклад фото, які будуть відображатися на веб-сторінках. Для зберігання фото-об’єктів використаємо окреме від бази даних сховище даних.
	В якості бази даних було обрано Azure SQL Database, яка буде працювати за допомоги SQL Server [3]. А в якості сховища даних використано Azure Blob-storage, для зберігання Blob-об’єктів.
	На рисунку 2.4 наведено ER-модель даних.


Рисунок 2.4 – ER-модель даних

	ER-модель даних показує нам структуру бази даних системи та взаємозв’язок між сутностями.


	2.3 Архітектура серверної частини


	За архітектуру для проєкту було взято MVC архітектуру. Її суть полягає в тому, що ми розділяємо проєкт на окремі компоненти. В нашому випадку ми виділили такі компоненти:
-	Models – моделі, класи, які описують наші сутності в базі даних.
-	Controllers – контролери, оброблюють дані користувачів. Тут реалізована уся бізнес логіка застосунку.
-	Routes – маршрути, відповідають за відображення даних користувачу, а також за запити від сервера або до серверу.


	2.4 Опис специфікації Rest API


	Для взаємодії серверу з іншими програмними шарами використовується Rest API. Опис специфікації Rest API наведено в таблиці Б.1.


	2.5 Кодування серверної частини


	На серверній частини реалізовано математичні методи для обробки даних користувачів, бізнес логіка та можливості управління бізнес логікою.
	Наведемо основну бізнес логіку:
-	Логіка роботи магазинів торгівельних центрів: реалізовано роботу магазину за допомогою методів для створення замовлень, додавання товарів до замовлень. Приклад програмного коду, який створює нове замовлення, наведено в додатку В. Даний метод створює нове замовлення та оброблює кількість товару на складі. У випадку недостатньої кількості товару користувач буде повідомлений.
-	Генерація та застосування знижки на замовлення для користувачів: реалізовано метод генерації знижки для користувачів, в залежності від кількості їх замовлень та витраченої суми грошей. Та також реалізовано метод застосування знижки до товару, в такому випадку ціна на товар зміниться на вказаний відсоток. Програмний код методів наведено в додатку В.
-	Автоматична генерація робочих змін для робітників: реалізовано метод, який автоматично додає робітнику нові робочі зміни на декілька днів в майбутнє, з врахування вихідних дней. Програмний код методу наведено в додатку В.
-	Аналіз відвідування магазинів користувачами: реалізовано метод, який підраховує та аналізує кількість користувачів в магазинах за деякий період, порівнює с поточним періодом, та робить висновок на скільки магазин завантажений на поточний час. Програмний код методу наведено в додатку В.


	2.6 Опис дотриманих вимог щодо захисту даних та безпеки в системі


	Відповідно до вимог щодо безпеки у програмній системі використовуються такі методи захисту даних:
-	Шифрування даних: у хмарній базі даних використовується шифрування даних, щоб ніхто не зміг отримати доступ до даних користувачів.
-	Хешування паролів: паролі користувачів, які зберігаються в базі даних захешовані, щоб ніхто не міг отримати до них доступ.
-	JWT токен: при авторизації користувача генерується Java Web Token, який має час існування 24 години. За допомогою цього токену сервер перевіряє, чи дійсно користувач авторизувався в системі та надає доступ до функціоналу.
	2.7 Реалізація локалізації та інтернаціоналізації в системі


	Відповідно до вимог до локалізації та інтернаціоналізації користувач може отримати текстові дані як англійською, так й українською мовою. Також, грошова валюта може бути оброблена в системі як в українських гривнях, так і в доларах США.


3 РОЗРОБКА КЛІЄНТСЬКОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ
	3.1 Архітектура клієнтської частини


	Структура клієнтської частини програмної системи має назву вертикальна слайсова архітектура. Відповідно до неї, ми маємо такі структурні директорії в даній частині:
-	pages – містить усі веб-сторінки, які відображаються користувачу;
-	components – деякі невеликі частини сторінок або інтерфейсу, які можуть використовуватися на веб-сторінках багато разів;
-	styles – CSS стилі, для коректного відображення веб-сторінок.
	Побудуємо діаграму пакетів, яка відобразить структуру клієнтської частини.


Рисунок 3.1 – UML діаграма пакетів клієнтської частини програмної системи

	Далі наведено пояснення елементів діаграми:
-	App – головний компонент системи, вхідна точка програми.
-	Styles – CSS стилі веб-сторінок.
-	Components – компоненти клієнтської частини.
-	Pages – веб-сторінки клієнтської частини.
-	Public – статичні файли клієнтської частини.
-	Resources – зображення, які використовуються на веб-сторінках.
	Далі спроєктуємо та створимо UML діаграму компонентів клієнтської частини.
	Для розробки діаграми компонентів були виділені такі структурні компоненти клієнтської частини:
-	Product – товар магазину.
-	Order – замовлення користувача.
-	Store – магазин в торговельному центрі.
-	Mall – торгівельний центр.
-	Shift – робоча зміна в магазині.
-	AttendanceChart – графік відвідування магазину користувачами.
	Розроблена UML діаграма компонентів наведена на рисунку 3.2.


Рисунок 3.2 – UML діаграма компонентів для клієнтської частини програмної системи

	Отже, ми розробили діаграму компонентів, яка показує архітектуру нашої системи з точки зору взаємодії її компонентів.
	3.2 Кодування клієнтської частини


	Клієнтська частина надає графічний інтерфейс для відображення реалізованої бізнес логіки:
-	Робота онлайн магазинів торгівельного центру. Клієнтська частина надає графічний інтерфейс для перегляду товарів магазинів, додавання товарів до кошику, підрахунок вартості замовлення, оформлення замовлення з врахуванням персональної знижки. В додатку Г наведено програмний код сторінки CartPage, де відбувається обробка та відображення кошика користувача, створення замовлення, застосування знижки до замовлення.
-	Робота з робочими змінами робітників в магазинах. Панель адміністратора надає йому функціонал перегляду робочих змін, а також автоматична генерація змін для працівників. Програмний код сторінки ShiftsPage для роботи зі змінами працівників наведено в додатку Г.
-	Сторінка для аналізу відвідування магазинів користувачами. Панель адміністратора надає йому функціонал для перегляду відвідування магазинів в графічному вигляді. А також отримання порад від системи щодо організації роботи магазину на основі відвідування. Програмний код сторінки AttandancePage для відображення графіку наведено в додатку Г.


4 РОЗРОБКА МОБІЛЬНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ
	4.1 Проєктування мобільної частини


	Мобільна частина програмної системи надає функціонал саме для певної ролі користувачів, а саме для робітника магазину торгівельного центру. Тому ми маємо розробити Use-case діаграму окремо для мобільної частини програмної системи. 	Робітник може виконувати наступні дії в системі:
-	Авторизація.
-	Вихід з системи.
-	Перегляд особистого профілю.
-	Перегляд замовлень користувачів. Зміна статусу замовлення.
-	Перегляд усіх та майбутніх робочих змін.
	Розроблена Use-case діаграма мобільної частини наведена на рисунку 4.1.


Рисунок 4.1 – Use-case діаграма мобільної частини програмної системи


	Також побудуємо UML діаграму станів мобільної частини. Для розробки діаграми станів були виділені такі процеси:
-	Авторизація.
-	Особистий профіль робітника.
-	Робота з замовленнями користувачів.
-	Робочі зміни.
	Розроблена діаграма станів наведена на рисунку 4.2.


Рисунок 4.2 – UML діаграма станів мобільної частини програмної системи

	Таким чином, ми побудували UML діаграму станів, яка показує нам поточний стан системи в будь який момент часу.


	4.2 Архітектура мобільної частини


	За архітектуру в застосунку було  взято шаблон MVC. Даний шаблон полягає в тому, щоб розділити структуру проєкту на частини:
-	Model – модель: сутності бази даних, з якими працює система.
-	Controller – контролер: обробляє запити до серверу.
-	View – представлення: відповідає за те, як дані будуть відображені користувачу, тобто графічний інтерфейс користувача.
	Також в структурі присутня допоміжна директорія api. Тека api відповідає за взаємодію мобільного застосунку та серверної частини.
	Створимо діаграму пакетів, для відображення структури нашого застосунку (див. рис. 4.3).


Рисунок 4.3 – UML діаграма пакетів мобільної частини програмної системи

	Далі наведено пояснення елементів діаграми:
-	Models – моделі, які описують сутності, з якими працює програмний код.
-	Controllers – контролери обробляють запити до серверу.
-	Api – налаштування доступу до api серверу.
-	Ui – усі графічні елементи, інтерфейс користувача для відображення даних.
	А також створимо діаграму компонентів мобільної частини (див. рис. 4.4).


Рисунок 4.4 – UML діаграма компонентів мобільної частини програмної системи

	На діаграмі наведено такі структурні компоненти:
-	MainActivity – головна сторінка застосунку, авторизація.
-	HomeActivity – сторінка, на яку потрапляє користувач після успішної авторизації, містить навігаційну панель для переходів на наступні сторінки.
-	HomeFragment – відображає профіль робітника.
-	OrderFragment – відображає замовлення в системі.
-	ShiftsFragment – відображає робочі зміни робітника.

	4.3 Реалізація локалізації в мобільній частині


	Інтерфейс користувача може бути перекладений українською та англійською мовами. Локалізація в даній програмній частині була реалізована за допомогою спеціального вбудованого у середовище розробки редактору для перекладу та файлів ресурсів для рядків.


ВИСНОВКИ


	В результаті виконання курсової роботи була спроєктована та розроблена програмна система для організації роботи торгівельного центру, яка складається з серверної, клієнтської та мобільної частин. Дана система є комплексним рішенням проблем в роботі великих торгівельних центрів, а саме: швидкий та зручний продаж та купівля товарів, управління замовленнями покупців, організація робочих змін для працівників та визначення рівня зацікавленості покупців магазинами.
	Програмна система була розроблена з дотриманням усіх вимог щодо захисту даних та безпеки, локалізації та інтернаціоналізації. Також в системі реалізовано можливість адміністрування, управління даними користувачів, а також можливість експорту даних системи. Було реалізовано складну бізнес логіку, яка використовує математичні методи, для обробки даних користувачів.
	Увесь запланований функціонал було реалізовано в повному обсязі.
	Розроблена програмна система може застосовуватись у сферах електронної комерції, бізнесу, а також для відстеження та управління робочими графіками в торгівельних центрах.
	Також програмну систему було розгорнуто за допомогою сервісу Microsoft Azure, так що вона може працювати не тільки в локальному режимі.


ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ

1.	Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides, Design Patterns. Elements of Reusable Object-oriented Software. Addsion Wesley Longman, Print. India East. Press, 1999. – 417 с.
2.	S. Newman, Monolith to Microservices: Evolutionary Patterns to Transform Your Monolith. O'Reilly Media, Inc., 2020. – 255 c.
3.	Azure SQL documentation – URL: https://learn.microsoft.com/en-us/azure/azure-sql/?view=azuresql (дата звернення: 03.04.2024).
4.	In4Suite ERP – URL: https://www.in4velocity.com/in4suite-erp/ (дата звернення: 24.03.2024).
5.	Software Engineering, Software Development and Systems Integration Partner – AllianceTek – URL: https://www.alliancetek.com/ (дата звернення: 24.03.2024).
6.	Відеоматеріали реалізованого проєкту в YouTube – URL: https://www.youtube.com/watch?v=QvoE-Rt7Mks.


ДОДАТОК А
Специфікація програмного забезпечення

1 БІЗНЕС-ВИМОГИ
	1.1 Передумови


	На сьогоднішній день робота торгівельного центру є дуже складним механізмом, який містить багато складових. Такі процеси, як продаж товарів, організація робочих місць в торгівельному центрі, а також аналітика зацікавленості покупців магазинами, можуть бути проблемою для великих мереж торгівельних центрів. Власники таких мереж зацікавлені в отриманні максимального прибутку та ефективному надані послуг, тому перелічені процеси треба автоматизувати або оптимізувати.
	Зі сторони покупців є проблема в придбанні товарів, адже іноді вони не хочуть фізично витрачати час в магазині, щоб обрати товар. Вони хочуть мати можливість обрати товар на онлайн платформі, а отримати його в фізичному магазині або навіть з доставкою до дому. В свою чергу, власники та робітники торгівельного центру зацікавлені у вирішенні даної проблеми, адже їх мета утримати клієнтів та зробити надання послуг максимально зручним та швидким.
	Також робітники та власники мереж торгівельних центрів зацікавлені в ефективній організації робочих місць. Якщо б вони мали інформацію про відвідування клієнтами магазинів, то могли ефективно створювати графіки для робітників, спираючись на аналітику відвідування магазинів.
	 Саме ці перелічені потреби та проблеми стали передумовою для створення програмної системи для організації роботи торгівельного центру.


	1.2 Бізнес-можливості


	Програмна система для організації роботи торгівельного центру	не є новою ідеєю, та вже має деякі реалізації на ринку.
	Один з таких конкурентів має назву «In4Suite» [4]. Даний сервіс надає послуги керування доходами та витратами для торгівельних центрів, управління арендою, звітність по ефективності роботи торгівельного центру. Це потужний інструмент, але його недоліком є те, що він створений саме для власників торгівельних центрів та менеджерів, та ніяк не вирішує потреби звичайних покупців.
	Іншим конкурентом є «AllianceTek» [5]. У порівнянні з попереднім сервісом, цей вже вирішує питання покупців та надає інструменти для просування торгівельного центру серед клієнтів. А також він надає послуги аналітики продаж в торгівельному центрі. Але недоліком даного сервісу є те, що він не вирішує проблему організації робітників торгівельного центру, а охоплює тільки бізнес складову.
	Наш сервіс орієнтований на ринок послуг, а також на ведення бізнесу. Наша програмна система вирішує такий комплекс проблем, який не охоплює ні один конкурент. Саме тому наш сервіс буде виділятися на ринку.
	Монетизація буде відбуватися за допомогою договорів, які будуть укладатися з мережами торгівельних центрів.


	1.3 Бізнес-цілі та критерії успіху


	BO-1: Залучити 10 мереж торгівельних центрів з усього світу.
	ВО-2: Залучити та утримати один мільйон клієнтів за перший рік.
	ВО-3: Залучити клієнтів з країн Європи та США.
	SC-1: Досягнення поставленої кількості мереж торгівельних центрів.
	SC-2: Протягом першого року кількість постійних користувачів сервісу тільки зростає.
	SC-3: Клієнти з країн Європи та США користуються сервісом постійно.


	1.4 Потреби клієнтів або ринку


	Потреби покупців торгівельного центру.
-	Купувати товари онлайн.
-	Відстежувати свої витрати та покупки.
-	Отримувати бонуси та акції від магазинів.
	Потреби власників торгівельного центру.
-	Ефективна організація робочих годин робітників та змін.
-	Утримання клієнтів торгівельного центру.


	1.5 Бізнес-ризики


	Бізнес-ризики, які можуть перешкодити розвитку проєкту та способи їх уникнення:
-	Конкуренція. Так як на ринку вже існують конкурентні компанії в нашій галузі, ми маємо надати користувачам унікальні послуги та функції, які будуть заохочувати користування саме нашим сервісом.
-	Потреба в постійному оновленні продукту. Ми маємо постійно вдосконалювати наш продукт, щоб утримати користувачів і завжди пропонувати кращі умови користування, ніж у конкурентів.
-	Технічні проблеми. Користувачі можуть стикнутися  з проблемами у використанні сервісом, у тому числі й технічними. Саме це може відштовхнути клієнтів у використанні саме нашим сервісом.
-	Законодавство інших країн. Особливості законодавства інших країн може вплинути на доступність в обробці деяких даних, що відповідно вплине на користування сервісом для людей з даних країн. Тому ми маємо дотримуватися правил обробки даних для усіх країн, на які націлений наш продукт та адаптувати сервіс відповідно вимог.


2 КОНЦЕПЦІЯ РІШЕННЯ
	2.1 Окреслення концепції


	Наш програмний продукт представляє собою систему для організації роботи торгівельного центру. Власники мереж торгівельних центрів зможуть розмістити на сервісі свій торгівельний центр. Тобто наш сервіс не є власне онлайн торгівельним центром, ми тільки надаємо послуги для розгортання різних мереж торгівельних центрів на платформі сервісу. Таким чином програмним продуктом можна буде скористатися власникам для організації робочих місць, відстеження зацікавленості клієнтів магазинів. А для покупців система представляє собою сервіс для продажу та покупки товарів з магазинів торгівельного центру, а також для відстеження своїх витрат та покупок в магазинах. Даним сервісом можна буде користуватися через веб-сайт або за допомогою мобільного застосунку.
	Отже, метою нашого програмного продукту є надання послуг для покупки та продажу товарів в торгівельних центрах, відстеження витрат на покупки, організація робочих місць в магазинах торгівельних центрів та відстеження поведінки та рівень зацікавленості покупців.


	2.2 Головна функціональність


	MF-1: Онлайн сервіс для продажу товарів магазинів торгівельного центру. Користувачі зможуть купувати товари з магазинів торгівельного центру за допомогою онлайн сервісу. Отримати замовлені товари можна буде за допомогою доставки по пошті або власне в фізичному магазині в торгівельному центрі.
	MF-2: Особистий кабінет покупця. В особистому кабінеті покупець зможе переглядати історію своїх покупок та замовлень, отримані знижки, та витрачений час відвідування магазинів та власне торгівельного центру.
	MF-3: Система знижок для покупців. Користувачі зможуть отримувати персональні знижки на товари, які будуть надаватися їм при певній кількості товарів в магазині або певній витраченій сумі.
	MF-4: Система для контролю робітників магазинів торгівельного центру. Також в нашій програмній системі буде інтегрована система для контролю робітників. Адміністратор магазину зможе відстежувати загальну кількість робітників в магазині, а також встановлювати кількість робітників в магазині на кожній зміні.
	MF-5: Отримання даних про відвідування магазинів та час відвідування кожного магазину покупцем. Розумний пристрій, який буде відстежувати час приходу та виходу користувача з магазину та вираховувати кількість витраченого часу в магазині. Таким чином ці дані можна використовувати для аналітики відвідування магазинів в торгівельному центрі.
	MF-6: Аналітика даних відвідування магазинів в торгівельному центрі. Дані щодо відвідування магазинів можна використати для визначення навантаження в певні дні та години магазину. В подальшому дану інформацію можна використати для визначення необхідної кількості робітників в магазинах у визначені дні та години, щоб вдосконалити їх роботу.


	2.3 Припущення та залежності


	Припущення:
-	Припускається, що користувачі мають доступ до Інтернету для використання основних функцій продукту.
-	Припускається, що програмний інтерфейс буде зрозумілий користувачам, для можливості користування сервісом.


Залежності:
-	Розробка продукту залежить від доступності та якості зовнішніх сервісів для платежів та збору даних, які можуть бути інтегровані в продукт.
-	Залежність від кількості контрактів, укладених з мережами торгівельних центрів.
-	Залежність від доступності необхідних технологічних платформ та мов програмування для розробки продукту.


3 РАМКИ ТА ОБМЕЖЕННЯ
	3.1 Рамки первинного випуску


	Далі наведено функціональність кожної складової системи, яка буде реалізована в первинному випуску програмного продукту.
Серверна частина:
-	Реєстрація та авторизація користувачів. Система повинна надавати можливість користувачам реєстрації та авторизації з використанням надійних методів аутентифікації.
-	Безпека та захист даних користувачів. Особисті дані користувачів не будуть доступні адміністраторам, паролі будуть зберігатися в хешованому вигляді, авторизація буде відбуватися через згенерований токен доступу.
-	Розподілення користувачів за ролями. В системі користувачі мають наступні ролі: покупець, адміністратор торгівельного центру, робітник магазину торгівельного центру. Користувачі будуть обмежені в функціоналі своїми ролями.
-	Адміністрування системи. Адміністратору торгівельного центру доступні функції адміністрування системи, а саме: функції експорту та імпорту даних, управління асортиментом магазинів, управління даними користувачів.
-	Мережі торгівельних центрів та відповідні в них магазини. Сервер має зберігати інформацію про торгівельні центри та магазини та оброблювати її.
	Інформація про користувачів. Сервер має зберігати інформацію про користувачів системи, також має надавати можливість змінювати її.
	Продаж та покупка товарів, оформлення замовлень. Сервер має зберігати дані про товари магазинів, історію замовлень та покупок, підраховувати вартість покупок та зберігати історію витрат.
	Аналітика даних відвідування магазинів покупцями та статистика. Сервер має зберігати дані про відвідування магазинів покупцями, формувати статистику та аналізувати ці дані. Потім ця аналітика буде застосовуватися для оптимізації робочих годин працівників та змін.
	Клієнтська частина:
-	Авторизація та реєстрація. Сервіс повинен надавати інтерфейс для авторизації та реєстрації користувачів.
-	Локалізація та інтернаціоналізація системи. Інтерфейс користувача має бути перекладеним на англійську та українську мови. А також підтримувати роботу з усіма часовими поясами.
-	Продаж та покупка товарів магазинів торгівельного центру та оформлення замовлень. Користувачу надається інтерфейс для перегляду доступних товарів, оформлення замовлення.
-	Панель адміністрування. Адміністраторам торгівельного центру надається інтерфейс користувача для виконання своїх функцій керування даними користувачів, асортиментом, експорту та імпорту даних.
-	Прийняття замовлень від покупців робітниками магазинів. Робітники магазинів мають інтерфейс для роботи із замовленнями покупців.
-	Особистий кабінет користувача. Покупцю надається інтерфейс користувача для перегляду, редагування своїх даних, перегляду історії покупок та замовлень, витрат.
	Мобільний застосунок:
-	Авторизація. Мобільний застосунок повинен надавати можливість авторизації користувачів.
-	Особистий кабінет користувача. Мобільний застосунок надає покупцю інтерфейс користувача для перегляду, редагування своїх даних, перегляду історії покупок та замовлень, витрат.
-	Продаж та покупка товарів магазинів торгівельного центру та оформлення замовлень. За допомогою мобільного застосунку користувач також зможе переглядати доступні товари магазину та оформлювати замовлення.

	3.2 Рамки наступних випусків


	У подальших випусках програмного продукту будуть реалізовані функції:
-	Оплата товарів через сервіс.
-	Система підписки на сервіс для мереж торгівельних центрів для надання усіх функцій.


	3.3 Обмеження та винятки


	Обмеження, які впливають на роботу нашої системи:
-	Інтернет-з'єднання: наша система потребує доступу до Інтернету для взаємодії з користувачами. Відсутність стабільного Інтернет-з'єднання може призвести до обмеження функціональності або зниження продуктивності.
-	Технічні обмеження: деякі функції системи можуть бути обмежені технічними характеристиками пристроїв користувачів. Наприклад, мобільний застосунок може мати обмежену продуктивність порівняно з веб-версією системи.
-	Безпека: забезпечення конфіденційності та безпеки даних користувачів є пріоритетним завданням. Будь-які обмеження, пов'язані з безпекою, повинні бути дотримані, щоб запобігти можливим загрозам.
Винятки:
-	Інші мережі: винятком є випадки, коли користувачі мають обмежений доступ до Інтернету через обмеженість власного інтернет-з'єднання. У таких випадках наша система може надавати обмежену функціональність офлайн або в обмеженому режимі.
-	Старі пристрої: користувачі зі старими пристроями або обмеженими технічними характеристиками можуть використовувати систему, але з меншою продуктивністю. Наша система повинна має бути оптимізована та забезпечувати підтримку для різних пристроїв і браузерів.
-	Незначні помилки: у випадку незначних помилок або порушень безпеки, система повинна мати механізми виявлення та виправлення проблем для запобігання подальшим порушенням безпеки та збереження даних користувачів.


4 БІЗНЕС-КОНТЕКСТ
	4.1 Профілі зацікавлених сторін


	У таблиці А.1 описані зацікавлені сторони проєкту.

	Таблиця А.1 – Профілі зацікавлених сторін
Зацікавлена сторона	Обмеження	Основні інтереси	Ставлення	Основна цінність
Покупці в торгівельних центрах	Обмеження в загальних функціях системи	Швидке обслуговування в магазині, онлайн придбання товарів	Вимоги до зручності, безпека та конфіденційність даних	Особистий час
Власники торгівельних центрів	Обмеження в бюджеті на просування торгівельного центру	Правильна та ефективна організація працівників на робочих місцях, утримання покупців	Очікують підвищення прибутку після початку користування сервісом	Прибуток
Робітники магазинів торгівельного центру	Обмеження відповідно своєї ролі в системі	Правильно організований робочий графік	Полегшення в роботі за допомогою користування сервісом	Заробітна плата, особистий час


	4.2 Пріоритети проєкту

	Наведені далі пріоритети вимог включать головну функціональність.
-	Онлайн платформа для продажу товарів, оформлення замовлень.
-	Особистий кабінет користувача для відстеження покупок, замовлень та витрат.
-	Система формування знижок та бонусів для покупців.
-	Функціонал для відстеження часу відвідування магазину користувачем.
-	 Оптимізація робочих годин для співробітників на основі навантаження магазинів.
Пріоритети бюджету: основний бюджет проєкту планується на розгортання та подальшу підтримку сервісу.
	До часу випуску програмного продукту планується реалізувати 100 відсотків запланованих функцій, відповідно пункту 2.2 Головна функціональність.


	4.3 Робоче середовище


	Для реалізації проєкту будуть застосовані наступні технології:
-	Для серверної частини веб-розробки буде використаний фреймворк Node JS, мова програмування Java Script та середовище розробки IntelliJ IDEA.
-	Для клієнтської частини веб розробки буде використана бібліотека React, мови програмування HTML, CSS, JavaScript, та середовище розробки Visual Studio Code.
-	Для створення мобільного додатку буде використана мова програмування Kotlin та середовище розробки Android Studio.
-	Для зберігання даних було обрано реляційну модель бази даних, хмарна база даних Azure SQL Database та СУБД Microsoft SQL Server Management Studio.
	Далі зазначено основні вимоги системи:
-	Доступність: система повинна бути доступною для користувачів протягом визначеного робочого часу без істотних перерв у роботі.
-	Надійність: система повинна бути стійкою до помилок та відновлюватися в разі аварій, щоб забезпечити безперебійну роботу.
-	Продуктивність: система повинна працювати швидко та ефективно, забезпечуючи швидкий доступ до даних та виконання операцій.
-	Цілісність: забезпечення цілісності даних та даних користувачів, щоб запобігти втраті або порушенню інформації.


ДОДАТОК Б
Таблиця для опису специфікації Rest API

	Таблиця Б.1 – Опис специфікації Rest API
Контролер: «Користувач»
Метод: GET
URL: /user
Опис: Отримати усіх користувачів
Контролер: «Користувач»
Метод: GET
URL: /profile
Опис: Отримати профіль користувача
Контролер: «Користувач»
Метод: POST
URL: /login
Опис: Авторизація
Контролер: «Користувач»
Метод: POST
URL: /registration
Опис: Реєстрація
Контролер: «Користувач»
Метод: PUT
URL: /savePassword
Опис: Редагувати пароль
Контролер: «Користувач»
Метод: PUT
URL: /saveProfile
Опис: Редагувати профіль
Контролер: «Мережа торгівельних центрів»
Метод: GET
URL: /mallChain
Опис: Отримати усі мережі торгівельних центрів
Контролер: «Мережа торгівельних центрів»
Метод: GET
URL: /mallChain/:id
Опис: Отримати мережу торгівельних центрів за ідентифікатором
Контролер: «Мережа торгівельних центрів»
Метод: POST
URL: /mallChain
Опис: Створити мережу торгівельних центрів
Контролер: «Мережа торгівельних центрів»
Метод: PUT
URL: /mallChain/:id
Опис: Редагувати мережу торгівельних центрів
Контролер: «Мережа торгівельних центрів»
Метод: DELETE
URL: /mallChain/:id
Опис: Видалити мережу торгівельних центрів
Контролер: «Торгівельний центр»
Метод: GET
URL: /mall
Опис: Отримати усі торгівельні центри
Контролер: «Торгівельний центр»
Метод: GET
URL: /mall/:id
Опис: Отримати торгівельний центр за ідентифікатором
Контролер: «Торгівельний центр»
Метод: POST
URL: /mall
Опис: Створити торгівельний центр
Контролер: «Торгівельний центр»
Метод: PUT
URL: /mall/:id
Опис: Редагувати торгівельний центр
Контролер: «Торгівельний центр»
Метод: DELETE
URL: /mall/:id
Опис: Видалити торгівельний центр
Контролер: «Магазин»
Метод: GET
URL: /store
Опис: Отримати усі магазини
Контролер: «Магазин»
Метод: GET
URL: /store/:id
Опис: Отримати магазин за ідентифікатором
Контролер: «Магазин»
Метод: GET
URL: /store/mall/:mallId
Опис: Отримати магазини за ідентифікатором торгівельного центру
Контролер: «Магазин»
Метод: POST
URL: /store
Опис: Створити магазин
Контролер: «Магазин»
Метод: PUT
URL: /store/:id
Опис: Редагувати магазин
Контролер: «Магазин»
Метод: DELETE
URL: /store/:id
Опис: Видалити магазин
Контролер: «Замовлення»
Метод: GET
URL: /order
Опис: Отримати усі замовлення
Контролер: «Замовлення»
Метод: GET
URL: /order/:id
Опис: Отримати замовлення за ідентифікатором
Контролер: «Замовлення»
Метод: GET
URL: /order/user/:id
Опис: Отримати усі замовлення користувача за його ідентифікатором
Контролер: «Замовлення»
Метод: POST
URL: /order
Опис: Створити замовлення
Контролер: «Замовлення»
Метод: PUT
URL: /order/:id
Опис: Редагувати замовлення
Контролер: «Деталі замовлення»
Метод: GET
URL: /orderDetails/order/:id
Опис: Отримати усі деталі замовлення за його ідентифікатором
Контролер: «Деталі замовлення»
Метод: GET
URL: /orderDetails/getSum/:id
Опис: Отримати суму замовлення за його ідентифікатором
Контролер: «Деталі замовлення»
Метод: POST
URL: /orderDetails
Опис: Створити деталі замовлення
Контролер: «Деталі замовлення»
Метод: POST
URL: /applyDiscount/:discount_id/:id
Опис: Застосувати знижку до деталей замовлення
Контролер: «Знижка»
Метод: GET
URL: /discount/:userId
Опис: Отримати усі доступні знижки для користувача за його ідентифікатором
Контролер: «Знижка»
Метод: POST
URL: /discount/:userId
Опис: Створити знижку для користувача за його ідентифікатором
Контролер: «Відвідування»
Метод: GET
URL: /attendanceAnalyze/store/:storeId
Опис: Отримати аналіз відвідування магазину за його ідентифікатором
Контролер: «Відвідування»
Метод: GET
URL: /attendance/store/:storeId/date/:date
Опис: Отримати відвідування магазину в обрану дату
Контролер: «Відвідування»
Метод: GET
URL: /attendance/store/:storeId/range/:dateFrom/:dateTo
Опис: Отримати відвідування магазину в обраний діапазон дат
Контролер: «Відвідування»
Метод: GET
URL: /attendanceCount/store/:storeId/date/:date
Опис: Підрахунок відвідувань в магазині в обрану дату
Контролер: «Відвідування»
Метод: GET
URL: /attendanceCount/store/:storeId/range/:dateFrom/:dateTo
Опис: Підрахунок відвідувань в магазині в обраний діапазон дат
Контролер: «Відвідування»
Метод: POST
URL: /attendance
Опис: Створити новий запис про відвідування
Контролер: «Робітник»
Метод: GET
URL: /worker
Опис: Отримати усіх робітників
Контролер: «Робітник»
Метод: GET
URL: /worker/store/:storeId
Опис: Отримати усіх робітників магазину
Контролер: «Робітник»
Метод: GET
URL: /worker/mall/:mallId
Опис: Отримати усіх робітників торгівельного центру
Контролер: «Робітник»
Метод: POST
URL: /worker
Опис: Створити робітника
Контролер: «Робоча зміна»
Метод: GET
URL: /workersBy/store/:storeId/date/:date
Опис: Отримати робітників, які мають зміни в обраному магазині в обрану дату
Контролер: «Робоча зміна»
Метод: GET
URL: /countWorkersBy/store/:storeId/date/:date
Опис: Підрахувати кількість робітників
Контролер: «Робоча зміна»
Метод: POST
URL: /shift
Опис: Створити зміну
Контролер: «Робоча зміна»
Метод: POST
URL: /generateShifts/:workerId
Опис: Згенерувати кілька змін для робітника


ДОДАТОК В
Програмний код серверної частини

	Наведемо програмний код обробки замовлення користувача:

1  exports.createOrder = async (req, res) => {
2      const { user_id, address, order_type } = req.body;
3      try {
4          const newOrder = await Order.create({ user_id, address,
5              order_type });
6          res.status(201).json(newOrder);
7      } catch (error) {
8          console.error('Error creating order:', error);
9          res.status(500).json({ message: 'Failed to create order',
10              error: error.message });
11      }
12  };
13
14  exports.createOrderDetails = async (req, res) => {
15      const { order_id, product_id, quantity } = req.body;
16
17      try {
18          const product = await Product.findByPk(product_id);
19          if (!product) {
20              return res.status(404).json({ message: 'Product not found' });
21          }
22
23          if (product.quantity < quantity) {
24              return res.status(400).json({ message: 'Insufficient quantity
25                  in stock' });
26          }
27
28          const orderDetails = await OrderDetails.create({
29              order_id,
30              product_id,
31              quantity
32          });
33
34          product.quantity -= quantity;
35          await product.save();
36
37          res.status(201).json(orderDetails);
38      } catch (error) {
39          console.error('Error creating order details:', error);
40          res.status(500).json({ message: 'Failed to create order details',
41              error: error.message });
42      }
43  };




	Наведемо програмний код методів обробки знижок користувача:

1  exports.generateDiscount = async (req, res) => {
2      const { userId } = req.params;
3
4      try {
5          const existingDiscount = await Discount.findOne({
6              where: {
7                  user_id: userId,
8                  is_used: 0,
9              }
10         });
11
12         if (existingDiscount) {
13             return res.status(200).json({ message: `User with id ${userId}
14                 already has an unused discount` });
15         }
16
17         const orders = await Order.findAll({
18             where: {
19                 user_id: userId,
20             }
21         });
22
23         let totalAmount = 0;
24
25         for (const order of orders) {
26             const orderDetails = await OrderDetails.findAll({
27                 where: {
28                     order_id: order.id,
29                 }
30             });
31
32             for (const detail of orderDetails) {
33                 const product = await Product.findByPk(detail.product_id);
34                 if (product) {
35                     totalAmount += product.price_usd * detail.quantity;
36                 }
37             }
38         }
39
40         if (totalAmount > 100) {
41             await Discount.create({
42                 user_id: userId,
43                 percent: 10,
44             });
45             res.status(201).json({ message: `Discount generated for user
46                 with id ${userId}` });
47         } else {
48             res.status(200).json({ message: `No discount generated for user
49                 with id ${userId}` });
50         }
51     } catch (error) {
52         console.error('Error generating discount:', error);
53         res.status(500).json({ message: 'Failed to generate discount',
54             error: error.message });
55     }
56 };
57
58 exports.applyDiscountToOrderDetails = async (req, res) => {
59     const { discount_id, id } = req.params;
60
61     try {
62         const discount = await Discount.findByPk(discount_id);
63         if (!discount) {
64             return res.status(404).json({ message: 'Discount not found' });
65         }
66
67         if (discount.is_used) {
68             return res.status(400).json({ message: 'Discount has already
69                 been used' });
70         }
71
72         const orderDetail = await OrderDetails.findByPk(id);
73         if (!orderDetail) {
74             return res.status(404).json({ message: 'Order detail not found' });
75         }
76
77         orderDetail.discount_id = discount_id;
78         await orderDetail.save();
79
80         discount.is_used = true;
81         await discount.save();
82
83         res.status(200).json({ message: 'Discount applied to order detail
84             successfully' });
85     } catch (error) {
86         console.error('Error applying discount to order detail:', error);
87         res.status(500).json({ message: 'Failed to apply discount to order
88             detail', error: error.message });
89     }
90 };

	Наведемо програмний код методу автоматичної генерації робочих змін для робітника:

1  exports.generateWorkerSchedule = async (req, res) => {
2      const { workerId } = req.params;
3
4      try {
5          const lastShift = await Shift.findOne({
6              where: { worker_id: workerId },
7              order: [['id', 'DESC']]
8          });
9
10         if (!lastShift) {
11             return res.status(400).json({ message: 'No shifts found for
12                 this worker' });
13         }
14
15         const schedule = lastShift.schedule;
16
17         const worker = await Worker.findByPk(workerId);
18         const storeId = worker.store_id;
19         const store = await Store.findByPk(storeId);
20
21         const { time_open, time_close } = store;
22
23         let currentDate;
24
25         const shifts = [];
26         if (lastShift.start_time) {
27             currentDate = addDays(lastShift.start_time, schedule + 1)
28         }
29         else {
30             currentDate = addDays(new Date, 1);
31         }
32
33         for (let i = 0; i < 2; i++) {
34             for (let j = 0; j < schedule; j++) {
35                 shifts.push({
36                     worker_id: workerId,
37                     start_time: new Date(currentDate.getFullYear(),
38                         currentDate.getMonth(), currentDate.getDate(),
39                         time_open.getHours(), time_open.getMinutes()),
40                     end_time: new Date(currentDate.getFullYear(),
41                         currentDate.getMonth(), currentDate.getDate(),
42                         time_close.getHours(), time_close.getMinutes()),
43                     schedule: schedule
44                 });
45                 currentDate = addDays(currentDate, 1);
46             }
47                 currentDate = addDays(currentDate, schedule);
48         }
49
50         console.log(shifts);
51
52         await Shift.bulkCreate(shifts);
53
54         res.status(200).json({ message: 'Worker schedule generated
55             successfully' });
56     } catch (error) {
57         console.error('Error generating worker schedule:', error);
58         res.status(500).json({ message: 'Error generating worker schedule',
59             error: error.message });
60     }
61 };

	Наведемо програмний код методу аналізу відвідування магазинів:

1  exports.analyzeAttendance = async (req, res) => {
2      const { storeId } = req.params;
3
4      try {
5          const endDate = new Date();
6          const startDate = new Date();
7          startDate.setDate(startDate.getDate() - 6);
8
9          const firstPeriodEndDate = new Date();
10         const firstPeriodStartDate = new Date();
11         firstPeriodStartDate.setDate(firstPeriodStartDate.getDate() - 6);
12         firstPeriodEndDate.setDate(firstPeriodEndDate.getDate() - 4);
13
14         const secondPeriodEndDate = new Date();
15         const secondPeriodStartDate = new Date();
16         secondPeriodStartDate.setDate(secondPeriodStartDate.getDate() - 3);
17         secondPeriodEndDate.setDate(secondPeriodEndDate.getDate() - 1);
18
19         const firstPeriodVisits = await Attendance.count({
20             where: {
21                 store_id: storeId,
22                 entry_time: {
23                     [Op.between]: [startDate, firstPeriodEndDate]
24                 }
25             }
26         });
27
28         const secondPeriodVisits = await Attendance.count({
29             where: {
30                 store_id: storeId,
31                 entry_time: {
32                     [Op.between]: [secondPeriodStartDate, endDate]
33                 }
34             }
35         });
36
37         let trend;
38         if (firstPeriodVisits > 0) {
39             const percentageChange = ((secondPeriodVisits -
40                 firstPeriodVisits) / firstPeriodVisits) * 100;
41             if (percentageChange > 0) {
42                 trend = 'Збільшилось';
43             } else if (percentageChange < 0) {
44                 trend = 'Зменшилось';
45             } else {
46                 trend = 'Не змінилося';
47             }
48         } else {
49             trend = 'Немає даних для аналізу';
50         }
51
52         let advice;
53         if (trend === 'Збільшилось') {
54             advice = 'Навантаження на магазин за останній час
55                 збільшилося. Рекомендовано мати 4 або 5 осіб персоналу на
56                 робочому місці в завантажені дні.';
57         } else if (trend === 'Зменшилось') {
58             advice = 'Навантаження на магазин за останній час
59                 зменшилося. Рекомендована мінімальна кількість
60                 консультантів в магазині - 3.';
61         } else {
62             advice = 'Поки що немає потреби в змінах, але варто
63                 продовжувати моніторити ситуацію.';
64         }
65
66         res.status(200).json({
67             firstPeriodVisits,
68             secondPeriodVisits,
69             trend,
70             advice
71         });
72     } catch (error) {
73         console.error('Помилка аналізу відвідуваності:', error);
74         res.status(500).json({ message: 'Помилка аналізу
75             відвідуваності', error: error.message });
76     }
77 };


ДОДАТОК Г
Програмний код клієнтської частини

	Наведемо програмний код сторінки CartPage:

1  import React, { useState, useEffect } from 'react';
2  import axios from 'axios';
3  import CartItem from '../components/CartItem';
4  import '../styles/CartPage.css';
5
6  const CartPage = () => {
7      const [cartItems, setCartItems] = useState([]);
8      const [phoneNumber, setPhoneNumber] = useState('');
9      const [storeAddress, setStoreAddress] = useState('');
10     const [totalPrice, setTotalPrice] = useState(0);
11     const [address, setAddress] = useState('');
12     const [orderType, setOrderType] = useState('Shipping');
13     const [discounts, setDiscounts] = useState([]);
14     const [applyDiscount, setApplyDiscount] = useState(false);
15
16     const apiUrl = process.env.REACT_APP_API_URL;
17
18     useEffect(() => {
19         const cartFromLocalStorage = localStorage.getItem('cart');
20         if (cartFromLocalStorage) {
21             setCartItems(JSON.parse(cartFromLocalStorage));
22         }
23     }, []);
24
25     useEffect(() => {
26         const fetchUserProfile = async () => {
27             try {
28                 const response = await axios.get(`${apiUrl}/profile`, {
29                     headers: {
30                         Authorization: `Bearer ${localStorage.getItem('token')}`,
31                     },
32                 });
33                 setPhoneNumber(response.data.phone_number);
34             } catch (error) {
35                 console.error('Error fetching user profile:', error);
36             }
37         };
38         fetchUserProfile();
39     }, []);
40
41     useEffect(() => {
42         const fetchStoreAndMall = async () => {
43             if (cartItems.length > 0) {
44                 const storeId = cartItems[0].store_id;
45                 try {
46                     const storeResponse = await axios.get(`${apiUrl}/store/${storeId}`);
47                     const mallId = storeResponse.data.mall_id;
48                     const mallResponse = await axios.get(`${apiUrl}/mall/${mallId}`);
49                     setStoreAddress(`${mallResponse.data.address}, ${storeResponse.data.name},
50                     floor ${storeResponse.data.floor}`);
51                 } catch (error) {
52                     console.error('Error fetching store or mall:', error);
53                 }
54             }
55         };
56         fetchStoreAndMall();
57     }, [cartItems]);
58
59     useEffect(() => {
60         const calculateTotalPrice = () => {
61             const total = cartItems.reduce((acc, item) => acc + item.price * item.num, 0);
62             setTotalPrice(total);
63         };
64         calculateTotalPrice();
65     }, [cartItems]);
66
67     useEffect(() => {
68         const fetchDiscounts = async () => {
69             try {
70                 const userId = localStorage.getItem('id');
71                 const response = await axios.get(`${apiUrl}/discount/${userId}`);
72                 setDiscounts(response.data);
73
74             } catch (error) {
75                 console.error('Error fetching discounts:', error);
76             }
77         };
78         fetchDiscounts();
79     }, [discounts]);
80
81     const removeFromCart = (id) => {
82         const updatedCartItems = cartItems.filter(item => item.id !== id);
83         setCartItems(updatedCartItems);
84         localStorage.setItem('cart', JSON.stringify(updatedCartItems));
85     };
86
87     const updateQuantity = (id, newQuantity) => {
88         const updatedCartItems = cartItems.map(item => {
89             if (item.id === id) {
90                 return { ...item, num: newQuantity };
91             }
92             return item;
93         });
94         setCartItems(updatedCartItems);
95         localStorage.setItem('cart', JSON.stringify(updatedCartItems));
96     };
97
98     const handleOrderTypeChange = (event) => {
99         const orderType = event.target.value;
100        setOrderType(orderType);
101        if (orderType === 'At store') {
102            setAddress(storeAddress);
103        } else {
104            setAddress('');
105        }
106    };
107
108    const handleOrder = async () => {
109        try {
110            const user_id = localStorage.getItem('id');
111            const newOrder = await axios.post(`${apiUrl}/order`, {
112                user_id,
113                address,
114                order_type: orderType,
115            });
116
117            const order_id = newOrder.data.id;
118
119            const orderDetailsPromises = cartItems.map(async item => {
120                return axios.post(`${apiUrl}/orderDetails`, {
121                    order_id,
122                    product_id: item.id,
123                    quantity: item.num,
124                });
125            });
126
127            const orderDetailResponses = await Promise.all(orderDetailsPromises);
128            const mostItemsOrderDetail = orderDetailResponses[0].data.id;
129
130            if (applyDiscount) {
131                await axios.post(`${apiUrl}/applyDiscount/${discounts[0].id}/${mostItemsOrderDetail}`);
132                alert("Discount applied!");
133            }
134
135            alert('Order created successfully!');
136            localStorage.removeItem('cart');
137            setCartItems([]);
138
139            const generateDiscountResponse = await axios.post(`${apiUrl}/discount/${user_id}`);
140
141            console.log(generateDiscountResponse.status);
142
143            if (generateDiscountResponse.status === 201){
144                alert("New discount for you generated!");
145            }
146
147        } catch (error) {
148            console.error('Error creating order:', error);
149            alert('Failed to create order');
150        }
151    };
152
153    return (
154        <div className="cart-page">
155            <div className="cart-items">
156                <h2>Your cart</h2>
157                {cartItems.length === 0 ? (
158                    <div className="empty-cart-message">
159                        <h3>Cart is empty</h3>
160                    </div>
161                ) : (
162                    cartItems.map(item => (
163                        <CartItem
164                            key={item.id}
165                            id={item.id}
166                            name={item.name}
167                            price={item.price}
168                            photo={item.photo}
169                            num={item.num}
170                            onRemove={removeFromCart}
171                            onUpdateQuantity={updateQuantity}
172                        />
173                    ))
174                )}
175            </div>
176            <div className="order-details">
177                <h2>Order Details</h2>
178                <div className="order-fields">
179                    <label htmlFor="address">Address:</label>
180                    <input type="text" id="address" name="address" value={address}
181                    onChange={e => setAddress(e.target.value)} />
182                    <label htmlFor="order-type">Order type:</label>
183                    <select id="order-type" name="order-type" value={orderType}
184                    onChange={handleOrderTypeChange}>
185                        <option value="Shipping">Shipping</option>
186                        <option value="At store">At Store</option>
187                    </select>
188                    <label htmlFor="phone-number">Phone Number:</label>
189                    <input type="tel" id="phone-number" name="phone-number" value={phoneNumber} readOnly />
190                </div>
191                <div className="order-total">
192                    <h3>Total Price: ${totalPrice.toFixed(2)}</h3>
193                </div>
194                <button className="order-button" onClick={handleOrder}>Order</button>
195            </div>
196            <div className="order-discounts">
197                <h2>Discounts</h2>
198                {discounts.length === 0 ? (
199                    <p>No discounts available</p>
200                ) : (
201                    <ul>
202                        {discounts.map(discount => (
203                            <div key={discount.id} className="discount">
204                                <p>Percent: {discount.percent}%</p>
205                                <h4>Discount {discount.is_used ? 'used' : 'not used'}</h4>
206                            </div>
207                        ))}
208                        <button
209                            className={`discount-button ${applyDiscount ? 'active' : ''}`}
210                            onClick={() => setApplyDiscount(!applyDiscount)}
211                        >
212                            Apply
213                        </button>
214                    </ul>
215                )}
216            </div>
217        </div>
218    );
219 };
220
221 export default CartPage;


	Наведемо програмний код сторінки ShiftsPage:

1  import React, { useState, useEffect } from 'react';
2  import axios from 'axios';
3  import { useParams } from 'react-router-dom';
4  import '../styles/ShiftsPage.css';
5
6  const ShiftsPage = () => {
7      const { id } = useParams();
8      const [shifts, setShifts] = useState([]);
9      const [showFutureShifts, setShowFutureShifts] = useState(false);
10     const [isLoading, setIsLoading] = useState(true);
11
12     const apiUrl = process.env.REACT_APP_API_URL;
13
14     useEffect(() => {
15         const fetchShifts = async () => {
16             try {
17                 const response = await axios.get(`${apiUrl}/${showFutureShifts ? 'futureShift' : 'shift'}/${id}`);
18                 setShifts(response.data);
19                 setIsLoading(false);
20             } catch (error) {
21                 console.error('Error fetching shifts:', error);
22                 setIsLoading(false);
23             }
24         };
25         fetchShifts();
26     }, [showFutureShifts, id]);
27
28     const handleGenerateShifts = async () => {
29         try {
30             await axios.post(`${apiUrl}/generateShifts/${id}`);
31             alert('Shifts generated successfully');
32             const response = await axios.get(`${apiUrl}/${showFutureShifts ? 'futureShift' : 'shift'}/${id}`);
33             setShifts(response.data);
34         } catch (error) {
35             console.error('Error generating shifts:', error);
36             alert('Failed to generate shifts');
37         }
38     };
39
40     if (isLoading) {
41         return <div>Loading...</div>;
42     }
43
44     return (
45         <div className="shifts-page">
46             <h1>Shifts for Worker #{id}</h1>
47             <div className="actions">
48                 <button className="generate-shifts-button" onClick={handleGenerateShifts}>
49                     Generate shifts for worker
50                 </button>
51                 <div className="toggle">
52                     <label>Show future shifts</label>
53                     <input
54                         type="checkbox"
55                         checked={showFutureShifts}
56                         onChange={() => setShowFutureShifts(!showFutureShifts)}
57                     />
58                 </div>
59             </div>
60             <div className="shifts-list">
61                 {shifts.map(shift => (
62                     <div key={shift.id} className="shift">
63                         <h2>{new Date(shift.start_time).toLocaleDateString()}</h2>
64                         <p><strong>Start Time:</strong> {new Date(shift.start_time).toISOString().slice(11, 16)}</p>
65                         <p><strong>End Time:</strong> {new Date(shift.end_time).toISOString().slice(11, 16)}</p>
66                     </div>
67                 ))}
68             </div>
69         </div>
70     );
71 };
72
73 export default ShiftsPage;

	Наведемо програмний код сторінки AttendancePage:

1  import React, { useState, useEffect } from 'react';
2  import axios from 'axios';
3  import { format } from 'date-fns';
4  import '../styles/AttendancePage.css';
5  import {
6      Chart as ChartJS,
7      BarElement,
8      CategoryScale,
9      LinearScale,
10     Tooltip,
11     Legend
12 } from "chart.js";
13
14 import { Bar } from 'react-chartjs-2';
15
16 ChartJS.register(
17     BarElement,
18     CategoryScale,
19     LinearScale,
20     Tooltip,
21     Legend
22 );
23
24 const AttendancePage = () => {
25     const [storeId, setStoreId] = useState('');
26     const [dateFrom, setDateFrom] = useState('');
27     const [dateTo, setDateTo] = useState('');
28     const [attendanceData, setAttendanceData] = useState([]);
29     const [visits, setVisits] = useState([]);
30     const [dates, setDates] = useState([]);
31     const [storeName, setStoreName] = useState('');
32     const [isLoading, setIsLoading] = useState(false);
33     const [stores, setStores] = useState([]);
34     const [advice, setAdvice] = useState('');
35     const [trend, setTrend] = useState('');
36
37     const apiUrl = process.env.REACT_APP_API_URL;
38
39     const data = {
40         labels: dates,
41         datasets: [
42             {
43                 label: storeName,
44                 data: visits,
45                 backgroundColor: '#c0c2ff',
46                 borderBlockColor: 'black',
47                 borderWidth: 1,
48             }
49         ]
50     };
51
52     const options = {};
53
54     useEffect(() => {
55         fetchStores();
56     }, []);
57
58     const fetchStores = async () => {
59         try {
60             const adminId = localStorage.getItem('id');
61             const mallResponse = await axios.get(`${apiUrl}/admin/${adminId}`);
62             const mallId = mallResponse.data.mall_id;
63
64             const storesResponse = await axios.get(`${apiUrl}/store/mall/${mallId}`);
65             setStores(storesResponse.data);
66         } catch (error) {
67             console.error('Error fetching stores:', error);
68         }
69     };
70
71     const fetchAttendanceData = async () => {
72         setIsLoading(true);
73         try {
74             const response = await axios.get(`${apiUrl}/attendanceDailyCount/store/${storeId}/range/${dateFrom}/${dateTo}`);
75             const response1 = await axios.get(`${apiUrl}/store/${storeId}`);
76
77             setAttendanceData(response.data);
78             setVisits(attendanceData.map(item => item.visits));
79             setDates(attendanceData.map(item => format(new Date(item.date), 'dd-MM-yyyy')));
80             setStoreName(response1.data.name);
81
82             setIsLoading(false);
83         } catch (error) {
84             console.error('Error fetching attendance data:', error);
85             setIsLoading(false);
86         }
87     };
88
89     const fetchAdvice = async () => {
90         try {
91             const response = await axios.get(`${apiUrl}/attendanceAnalyze/store/${storeId}`);
92             setTrend(response.data.trend);
93             setAdvice(response.data.advice);
94         } catch (error) {
95             console.error('Error fetching advice:', error);
96         }
97     };
98
99     const handleSubmit = (e) => {
100        fetchAttendanceData();
101        fetchAdvice();
102        e.preventDefault();
103    };
104
105    return (
106        <div className="attendance-page">
107            <h1>Attendance</h1>
108            {advice && trend && (
109                <div className="advice-container">
110                    <h2>Trend: {trend}</h2>
111                    <p>{advice}</p>
112                </div>
113            )}
114            <form onSubmit={handleSubmit}>
115                <div className="form-group">
116                    <label>Store:</label>
117                    <select value={storeId} onChange={(e) => setStoreId(e.target.value)} required>
118                        <option value="">Select a store</option>
119                        {stores.map(store => (
120                            <option key={store.id} value={store.id}>{store.name}</option>
121                        ))}
122                    </select>
123                </div>
124                <div className="form-group">
125                    <label>Date From:</label>
126                    <input type="date" value={dateFrom} onChange={(e) => setDateFrom(e.target.value)} required />
127                </div>
128                <div className="form-group">
129                    <label>Date To:</label>
130                    <input type="date" value={dateTo} onChange={(e) => setDateTo(e.target.value)} required />
131                </div>
132                <button type="submit">Get chart</button>
133            </form>
134            <div className="chart-container">
135                {attendanceData.length > 0 ? (
136                    <div>
137                        <Bar
138                            data={data}
139                            options={options}
140                        ></Bar>
141                    </div>
142                ) : <div>No data to display</div>}
143            </div>
144
145        </div>
146    );
147 };
148
149 export default AttendancePage;